import pandas as pd
import numpy as np
import io
import logging
import os
import tempfile
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from app.utils.preprocessing import extract_features, hash_file
from sklearn.exceptions import NotFittedError
from pefile import PEFormatError

class MalwareService:
    def __init__(self, input_shape):
        self.malware_detector = MalwareDetector(input_shape)
        self.scaler = StandardScaler()
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        self.X_train = []
        self.y_train = []

    def fit_scaler(self, processed_data):
        self.logger.info("Fitting the StandardScaler with data")
        self.scaler.fit(processed_data)
        self.logger.info("StandardScaler fitted successfully: mean_=%s, var_=%s", self.scaler.mean_, self.scaler.var_)

    def fit_and_scale(self, data):
        self.logger.info("Starting the adjustment and transformation of the data")
        self.fit_scaler(data)
        return self.scaler.transform(data)

    def scan_malware(self, file_content):
        self.logger.info("Starting malware scan")
        try:
            features = self.extract_features_from_content(file_content)
            self.logger.info("Features extracted for scanning: %s", features)
        except PEFormatError as e:
            self.logger.error("Error processing PE file: %s", str(e))
            raise ValueError("Error processing PE file: %s" % str(e))
        scaled_data = self.fit_and_scale(features)
        self.logger.info("Escalated data for scanning: %s", scaled_data)
        threats = self.malware_detector.detect(scaled_data)
        result = {"threats": threats}
        self.logger.info("Scan Result: %s", result)
        
        # Self-training based on the results of the analysis
        if "Malicious" in threats:
            self.add_training_data(file_content, 1)
        else:
            self.add_training_data(file_content, 0)
        self.train_model()

        return result

    def extract_features_from_content(self, file_content):
        self.logger.info("Extraindo features do arquivo")
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as temp_file:
            temp_file.write(file_content)
            temp_file_path = temp_file.name
        
        self.logger.info("Temporary file created on: %s", temp_file_path)
        self.logger.info("Temporary file size: %d bytes", len(file_content))
        
        # Make sure the file is not empty before processing
        if os.path.getsize(temp_file_path) == 0:
            raise PEFormatError('O arquivo estÃ¡ vazio')

        try:
            features = extract_features(temp_file_path)
        except PEFormatError as e:
            self.logger.error("Error reading DOS header: %s", str(e))
            raise
        hashed = hash_file(temp_file_path)
        self.logger.info("Extracted Features: %s", features)
        self.logger.info("File Hash: %s", hashed)
        return np.array(list(features.values())).reshape(1, -1)

    def add_training_data(self, file_content, label):
        self.logger.info("Adding Training Data")
        features = self.extract_features_from_content(file_content)
        self.X_train.append(features)
        self.y_train.append(label)
        self.logger.info("Training data successfully added")

    def train_model(self):
        if not self.X_train or not self.y_train:
            self.logger.info("No training data available, skipping training")
            return
        
        self.logger.info("Training the Model with the Training Data")
        X_train = np.vstack(self.X_train)
        y_train = np.array(self.y_train)
        self.logger.info("Training Data: X_train=%s, y_train=%s", X_train, y_train)
        self.fit_scaler(X_train)
        scaled_X_train = self.scaler.transform(X_train)
        self.logger.info("Staggered training datas: %s", scaled_X_train)
        self.malware_detector.train(scaled_X_train, y_train)
        self.logger.info("Successfully trained model")

class MalwareDetector:
    def __init__(self, input_shape):
        self.model = Sequential([
            Dense(64, activation='relu', input_shape=input_shape),
            Dense(32, activation='relu'),
            Dense(1, activation='sigmoid')
        ])
        self.model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

    def train(self, data, labels):
        self.model.fit(data, labels, epochs=10)

    def detect(self, new_data):
        predictions = self.model.predict(new_data)
        return ["Malicious" if p > 0.5 else "Safe" for p in predictions]
