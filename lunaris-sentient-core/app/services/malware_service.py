import pandas as pd
import numpy as np
import io
import logging
import os
import tempfile
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from app.utils.preprocessing import extract_features, hash_file
from sklearn.exceptions import NotFittedError
from pefile import PEFormatError

class MalwareService:
    def __init__(self, input_shape):
        self.malware_detector = MalwareDetector(input_shape)
        self.scaler = StandardScaler()
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        self.X_train = []
        self.y_train = []

    def fit_scaler(self, processed_data):
        self.logger.info("Fitting the StandardScaler with data")
        self.scaler.fit(processed_data)
        self.logger.info("StandardScaler fitted successfully: mean_=%s, var_=%s", self.scaler.mean_, self.scaler.var_)

    def fit_and_scale(self, data):
        self.logger.info("Iniciando o ajuste e transformação dos dados")
        self.fit_scaler(data)
        return self.scaler.transform(data)

    def scan_malware(self, file_content):
        self.logger.info("Iniciando escaneamento de malware")
        try:
            features = self.extract_features_from_content(file_content)
            self.logger.info("Features extraídas para escaneamento: %s", features)
        except PEFormatError as e:
            self.logger.error("Erro ao processar o arquivo PE: %s", str(e))
            raise ValueError("Erro ao processar o arquivo PE: %s" % str(e))
        scaled_data = self.fit_and_scale(features)
        self.logger.info("Dados escalonados para escaneamento: %s", scaled_data)
        threats = self.malware_detector.detect(scaled_data)
        result = {"threats": threats}
        self.logger.info("Resultado do escaneamento: %s", result)
        
        # Auto-treinamento com base nos resultados da análise
        if "Malicious" in threats:
            self.add_training_data(file_content, 1)
        else:
            self.add_training_data(file_content, 0)
        self.train_model()

        return result

    def extract_features_from_content(self, file_content):
        self.logger.info("Extraindo features do arquivo")
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as temp_file:
            temp_file.write(file_content)
            temp_file_path = temp_file.name
        
        self.logger.info("Arquivo temporário criado em: %s", temp_file_path)
        self.logger.info("Tamanho do arquivo temporário: %d bytes", len(file_content))
        
        # Verifique se o arquivo não está vazio antes de processar
        if os.path.getsize(temp_file_path) == 0:
            raise PEFormatError('O arquivo está vazio')

        try:
            features = extract_features(temp_file_path)
        except PEFormatError as e:
            self.logger.error("Erro ao ler o cabeçalho DOS: %s", str(e))
            raise
        hashed = hash_file(temp_file_path)
        self.logger.info("Features extraídas: %s", features)
        self.logger.info("Hash do arquivo: %s", hashed)
        return np.array(list(features.values())).reshape(1, -1)

    def add_training_data(self, file_content, label):
        self.logger.info("Adicionando dados de treinamento")
        features = self.extract_features_from_content(file_content)
        self.X_train.append(features)
        self.y_train.append(label)
        self.logger.info("Dados de treinamento adicionados com sucesso")

    def train_model(self):
        if not self.X_train or not self.y_train:
            self.logger.info("Nenhum dado de treinamento disponível, pulando treinamento")
            return
        
        self.logger.info("Treinando o modelo com os dados de treinamento")
        X_train = np.vstack(self.X_train)
        y_train = np.array(self.y_train)
        self.logger.info("Dados de treinamento: X_train=%s, y_train=%s", X_train, y_train)
        self.fit_scaler(X_train)
        scaled_X_train = self.scaler.transform(X_train)
        self.logger.info("Dados de treinamento escalonados: %s", scaled_X_train)
        self.malware_detector.train(scaled_X_train, y_train)
        self.logger.info("Modelo treinado com sucesso")

class MalwareDetector:
    def __init__(self, input_shape):
        self.model = Sequential([
            Dense(64, activation='relu', input_shape=input_shape),
            Dense(32, activation='relu'),
            Dense(1, activation='sigmoid')
        ])
        self.model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

    def train(self, data, labels):
        self.model.fit(data, labels, epochs=10)

    def detect(self, new_data):
        predictions = self.model.predict(new_data)
        return ["Malicious" if p > 0.5 else "Safe" for p in predictions]
