import os
import logging
import numpy as np
from tqdm import tqdm
from app.utils.preprocessing import extract_features, preprocess_malware_data
from app.models.malware_detector import MalwareDetector
from apscheduler.schedulers.background import BackgroundScheduler
from sklearn.metrics import classification_report
from imblearn.over_sampling import SMOTE

class MalwareService:
    def __init__(self, input_shape):
        self.logger = logging.getLogger(__name__)
        self.logger.info("Initializing MalwareService")
        self.malware_detector = MalwareDetector(input_shape)
        self.training_data_dir = 'training_data'
        os.makedirs(self.training_data_dir, exist_ok=True)
        self.model_trained = False
        self.scheduler = BackgroundScheduler()
        self.scheduler.add_job(self.retrain_model, 'interval', days=1)
        self.scheduler.start()
        self.logger.info("MalwareService initialized successfully")

    def _load_data_from_directory(self):
        X_train = []
        y_train = []
        for label in [0, 1]:
            label_dir = os.path.join(self.training_data_dir, str(label))
            for filename in tqdm(os.listdir(label_dir), desc=f"Loading data for label {label}"):
                file_path = os.path.join(label_dir, filename)
                with open(file_path, 'rb') as file:
                    filedata = file.read()
                    features = extract_features(filedata)
                    if len(features) == 10:  # Adjust the number of features
                        X_train.append(features)
                        y_train.append(label)
        
        if len(X_train) == 0 or len(y_train) == 0:
            self.logger.error("No training data available")
            return np.array([]), np.array([])

        return np.array(X_train), np.array(y_train)

    def load_training_data(self):
        X_train, y_train = self._load_data_from_directory()

        n_neighbors = min(5, len(X_train) - 1)
        smote = SMOTE(k_neighbors=n_neighbors)

        X_train, y_train = smote.fit_resample(X_train, y_train)
        return X_train, y_train

    def train_model(self):
        self.logger.info("Starting model training")
        X_train, y_train = self.load_training_data()
        if len(X_train) == 0 or len(y_train) == 0:
            self.logger.error("No training data available")
            return
        scaled_X_train = preprocess_malware_data(X_train, fit=True)
        self.logger.info("Training model...")
        for _ in tqdm(range(1), desc="Training model"):
            self.malware_detector.train(scaled_X_train, y_train)
        self.model_trained = True
        self.logger.info("Model trained successfully")
        self.evaluate_model()

    def retrain_model(self):
        self.logger.info("Retraining model with new data")
        self.train_model()

    def evaluate_model(self):
        self.logger.info("Evaluating model performance")
        try:
            X_train, y_train = self.load_training_data()
            if len(X_train) == 0 or len(y_train) == 0:
                self.logger.error("No training data available for evaluation")
                return
            scaled_X_train = preprocess_malware_data(X_train)
            self.logger.info(f"Scaled training data: {scaled_X_train}")
            y_pred = self.malware_detector.model.predict(scaled_X_train)
            report = classification_report(y_train, y_pred)
            self.logger.info(f"Model evaluation report:\n{report}")
        except Exception as e:
            self.logger.error(f"Error evaluating model: {e}")

    def scan_malware(self, filedata):
        try:
            if not self.model_trained:
                self.logger.error("Model is not trained yet")
                raise ValueError("Model is not trained yet")
            
            self.logger.info("Extracting features from file")
            features = extract_features(filedata)
            self.logger.info(f"Extracted features: {features}")
            if len(features) != 10:
                raise ValueError(f"Expected 10 features, but got {len(features)}")
            scaled_features = preprocess_malware_data([features])
            self.logger.info(f"Scaled features: {scaled_features}")
            self.logger.info("Scanning file...")
            for _ in tqdm(range(1), desc="Scanning file"):
                prediction = self.malware_detector.predict(scaled_features)
            prediction_value = float(prediction[0]) if isinstance(prediction, (list, np.ndarray)) else float(prediction)
            self.logger.info(f"File scanned successfully, prediction: {prediction_value}")
            return prediction_value
        except Exception as e:
            self.logger.error(f"Error scanning file: {e}")
            return None

    def save_training_file(self, filename, filedata, label):
        label_dir = os.path.join(self.training_data_dir, str(label))
        os.makedirs(label_dir, exist_ok=True)
        file_path = os.path.join(label_dir, filename)
        with open(file_path, 'wb') as f:
            f.write(filedata)
        self.logger.info(f"File {filename} saved with label {label}")

    def process_file(self, file, label):
        filename = file.filename
        filedata = file.read()
        self.save_training_file(filename, filedata, label)
        self.retrain_model()
